{"version":3,"sources":["components/UI/Button.tsx","components/UI/Button.module.scss","components/Form/Input.tsx","components/Form/Input.module.scss","utils/intoParsable.ts","utils/preprocessMarkdown.ts","pages/Admin/Editors/NoticeBanner.module.scss","pages/Admin/Editors/bottomToolbar.module.scss","pages/Admin/Editors/RichTextEditor.module.scss","pages/Admin/Editors/NoticeBanner.tsx","pages/Admin/Editors/RichTextEditWidgetInformation.tsx","pages/Admin/Editors/RichTextEditor.tsx","pages/Admin/Admin.tsx"],"names":["Button","children","type","styledAs","props","className","styles","button","default","module","exports","Input","changeHandler","label","value","option","readOnly","selectAllOnFocus","InputOrTextarea","inputRef","useRef","group","ref","textarea","input","onChange","onFocus","current","select","shrink","intoParsable","current_character_index","still_parsing","length","peek_character","look_ahead_offset","eat_character","result","withPreservedPosition","progn_fn","restoration_index","stillParsing","peekCharacter","requireCharacter","character","eatCharacter","consumeUntil","ending_predicate_fn","tryParseString","parsable","delimiter","acceptMultiline","successful_parse","string_contents","withEatWhitespace","procedure","peeked","eatWhitespace","peekWhitespaceSeparatedCharacter","p","requireWhitespaceSeparatedCharacter","c","eatWhitespaceSeparatedToken","eatWhitespaceSeparatedString","options","pipeSeparatorErrorCheck","console","error","preprocessMarkdown","stringInput","actualResult","processed","imageLinks","headers","nextCharacter","has_end","inbetween","image_tag","floatingMethod","captionString","property","maybe_string","push","value_identifier","captionImagePreview","log","floatingMethodStr","floatLeft","floatCenter","floatRight","captionBox","width","captionBoxInner","headerCount","textContents","level","text","NoticeBanner","dirtyFlag","noticeBannerStyles","dropOut","dropIn","useState","selfDirtyFlag","updateSelfDirtyFlag","style","updateStyle","main","widgets","heading","active","types","h1","name","display","command","argument","category","h2","h3","h4","h5","h6","image","list","orderedList","unorderedList","bold","italic","underline","hyperlink","ImageDimensionsType","LayoutFloatMode","unsafeDOMStyleSet","element","unsafeReferenceSet","ExecuteRichTextCommand","commandName","optionalArgument","hookFn","fileDialog","document","createElement","click","addEventListener","fileHandlerOnChange","execCommand","queryRichTextCommand","wantedValue","queryCommandValue","queryCommandState","probablyFile","target","files","retrieveImageData","imgData","uploadImage","then","imgURL","success","data","url","editorHandleKeybindings","saveDocument","toggleWidget","executeRichTextCommand","updateDirtyFlag","event","key","shiftKey","disableDefaultBehavior","ctrlKey","preventDefault","stopPropagation","EditorToolbar","toggleDraftStatus","isInitial","bottomToolbarStyle","onClick","TagDisplay","id","removeTag","editorStyle","tageditor_tag","_","ArticleTagEditor","tags","setTagState","setInput","removeTagById","filter","tagName","tageditor","map","tag","onKeyDown","slice","indexOf","concat","imageDOMGetCaption","rootNode","captionTextContents","parentNode","classList","contains","articleStyles","getElementsByClassName","textContent","captionImageThumbnailStyleString","height","captionImageBlockStyleString","floatModeStyle","layoutFloatMode","Left","Center","Right","imageDOMHasCaption","undefined","ImageContextSettings","properties","imageObject","imageRef","captionInformation","originalWidth","originalHeight","trim","imageCaptionText","setImageCaptionText","styleFromClassList","imageDOMGetFloatStyle","setLayoutFloatMode","imageAllowsWrapAround","Default","imageDimensionType","setImageDimensionType","imageDimensionCustomWidth","setImageDimensionCustomWidth","imageDimensionCustomHeight","setImageDimensionCustomHeight","scaleByGivenRatio","ratio","Math","floor","blotOut","settingsWindow","imageContextSettingsWindow","closeShownStatus","xOut","margin","textAlign","src","imagePreview","dangerouslySetInnerHTML","__html","contextGroupedRadio","currentlySelected","e","Custom","unfocused","dimensionPicker","Number","parseInt","defaultValue","alignToBottom","newWidth","newHeight","hasCaption","imageNode","toggle","classListReplace","imageDOMUpdateCaptionWithNoChecks","captionBuildResult","imageOriginalNode","captionText","innerHTML","innerResult","firstChild","firstInnerChild","childNodes","AssertionError","captionNode","imageDOMConstructCaptionedImage","replaceWith","classListClear","add","noWrapAroundText","HyperlinkContextSettings","hyperlinkText","setHyperlinkText","hyperlinkAnchorText","setHyperlinkAnchorText","useEffect","selectionStackPush","hyperlinkContextSettingsWindow","hyperlinkRef","selectionStackPop","href","absolutePositionAt","x","y","position","left","top","ImageContextMenu","openEdit","close","contextMenu","remove","HyperlinkContextMenu","link","RichTextEditor","submissionHandler","currentArticle","initialArticleState","tagEditorShown","setTagEditorVisibility","imageContextEditorShown","setImageContextEditorVisibility","hyperlinkContextEditorShown","setHyperlinkContextEditorShown","editableTitleDOMRef","editableAreaDOMRef","currentImageRef","currentHyperlinkRef","imageContextMenuPosition","setImageContextMenuPosition","hyperLinkContextMenuPosition","setHyperLinkContextMenuPosition","onmousedown","offsetLeft","offsetTop","widgetStates","updateWidgetState","markdownText","renderDomAsMarkdown","content","renderMarkdown","_toggleWidgetActiveState","widgetId","categoryValue","dictionaryUpdateKeyNested","currentlyActive","toggleWidgetActiveState","title","contentEditable","article","minHeight","onSelect","currentSelection","window","getSelection","anchorNode","isVoidElement","anchorNodeAsElement","nextElementSibling","collapse","goodTarget","nextSibling","collapseToEnd","put_the_cursor_in_a_fucking_place_i_can_actually_type_in","Object","keys","reduce","newWidgetState","widgetbar","float","marginLeft","entries","accumulator","copy","widget","marginRight","Admin","dispatch","useAppDispatch","draftStatus","updateDraftStatus","submissionData","onFinishedCallback","insertArticle"],"mappings":"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","file":"static/js/0.cf532d66.chunk.js","sourcesContent":["import styles from \"./Button.module.scss\";\n\nfunction Button({\n  children,\n  type = \"button\",\n  styledAs,\n  ...props\n}: {\n  children: string;\n  styledAs?: \"oval\";\n} & React.DetailedHTMLProps<React.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>\n) {\n  return (\n    <button\n      className={`\n        ${styles.button} \n        ${styledAs ? styles[styledAs] : styles.default} \n        ${props.className || \"\"}\n      `}\n      type={type}\n      {...props}\n    >\n      {children}\n    </button>\n  );\n}\n\nexport default Button;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button_button__1_sNH\",\"default\":\"Button_default__1hCTa\",\"oval\":\"Button_oval__Z1YBF\"};","import styles from \"components/Form/Input.module.scss\";\nimport { useRef } from \"react\";\n\nexport interface InputOptions {\n  type?: string,\n  placeholder?: string;\n  readOnly?: boolean;\n  required?: boolean;\n\n  option?: \"input\" | \"textarea\";\n  label?: string;\n  defaultValue?: string,\n  selectAllOnFocus?: boolean;\n}\n\nexport type ChangeHandler = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;\n\nconst Input = ({\n  changeHandler,\n  label,\n  value,\n  option,\n  readOnly,\n  selectAllOnFocus,\n  ...props\n}: {\n  changeHandler?: ChangeHandler;\n  name?: string;\n  label?: string;\n  value: string;\n} & InputOptions\n) => {\n  const InputOrTextarea = option || \"input\";\n  const inputRef = useRef<HTMLInputElement & HTMLTextAreaElement>(null);\n\n  return (\n    <div className={styles.group}>\n      <InputOrTextarea\n        ref={inputRef}\n        className={(\n          option === \"textarea\"\n        ) ? styles.textarea\n          : styles.input\n        }\n        onChange={changeHandler}\n        {...((\n          selectAllOnFocus\n        ) && {\n          onFocus: () => inputRef.current?.select()\n        })}\n        {...((\n          readOnly\n        ) && {\n          readOnly: true\n        })}\n        {...props}\n      />\n      {\n        label && (\n          <label\n            className={`${value ? styles.shrink : \"\"}`}\n          >\n            {label}\n          </label>\n        )\n      }\n    </div>\n  );\n};\n\nexport default Input;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"group\":\"Input_group___CkTD\",\"form-input-label\":\"Input_form-input-label__3LBb9\",\"shrink\":\"Input_shrink__1Oknc\"};","/*\n  Parsable is an interface produced from a string input.\n  \n  It'll convert a string into a `Parsable` object which removes the\n  ability to modify the string, and instead replaces it with reading\n  facilities that would be very useful for tokenizing or lexical analysis.\n  \n  To use just do:\n\n  object = intoParsable(\"abcdefghijklmnop\");\n  \n  There's also a few premade parsable functions that aid in building parsers.\n*/\n\n// Semantic type. There is no such thing as a char\n// and an enforced type might explode stuff (string.length === 1?)\n// considering Unicode is a thing, and the planes might break it depending on\n// how .length calculates.\ntype char = string;\n\nexport interface Parsable {\n  withPreservedPosition: (progn: () => unknown) => unknown;\n  stillParsing: () => boolean,\n  peekCharacter: () => char | null,\n  eatCharacter: () => char | null,\n  requireCharacter: (c: char) =>  boolean,\n  consumeUntil: (predicate: () => boolean) => string,\n}\n\nexport function intoParsable(input: string) : Parsable {\n  // I'm internally using snake_case because I'm comfortable with it\n  // but everyone else uses camel case.\n  let current_character_index = 0;\n\n  function still_parsing() {\n    return (current_character_index < input.length);\n  }\n\n  function peek_character(look_ahead_offset = 0) {\n    if (current_character_index + look_ahead_offset > input.length) {\n      return null;\n    } else {\n      return input[current_character_index + look_ahead_offset];\n    }\n  }\n\n\n  function require_character(character: char) {\n    if (peek_character() === character) {\n      eat_character();\n      return true;\n    }\n    return false;\n  }\n\n  function eat_character() {\n    if (current_character_index > input.length) {\n      return null;\n    } else {\n      const result = peek_character();\n      current_character_index++;\n      return result;\n    }\n  }\n\n  function consume_until(ending_predicate_fn: () => boolean) {\n    let result = \"\";\n\n    while (still_parsing()) {\n      if (ending_predicate_fn()) {\n        break;\n      } else {\n        result += eat_character();\n      }\n    }\n\n    return result;\n  }\n\n  function with_preserved_position(progn_fn: () => unknown) {\n    const restoration_index = current_character_index;\n    const result = progn_fn();\n    current_character_index = restoration_index;\n    return result;\n  }\n\n  return {\n    withPreservedPosition: with_preserved_position,\n    stillParsing: still_parsing,\n    peekCharacter: peek_character,\n    requireCharacter: require_character,\n    eatCharacter: eat_character,\n    consumeUntil: consume_until,\n  };\n}\n\n/*\n  This is the kit of useful stuff that you probably want to\n  use with this thing.\n\n  Probably named too verbosely.\n*/\n\n// TODO(jerry): add escaped characters!\ninterface TryParseStringOptions {\n  delimiter: char,\n  acceptMultiline?: boolean,\n}\nexport function tryParseString(parsable: Parsable, { delimiter, acceptMultiline } : TryParseStringOptions) {\n  if (parsable.requireCharacter(delimiter)) {\n    let successful_parse = true;\n    const string_contents = parsable.consumeUntil(\n      function () {\n        if (!acceptMultiline && parsable.requireCharacter(\"\\n\")) {\n          successful_parse = false;\n          return true;\n        } else if (parsable.requireCharacter(delimiter)) {\n          return true;\n        }\n        return false;\n      }\n    );\n    if (string_contents && successful_parse) {\n      return string_contents;\n    }\n  }\n\n  return null;\n}\n\nconst is_literal_acceptable = (c: char | null) => c && ((c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\") || (c >= \"0\" && c <= \"9\"));\nexport function eatIdentifier(parsable: Parsable) {\n  if (parsable.stillParsing()) {\n    return parsable.consumeUntil(() => !is_literal_acceptable(parsable.peekCharacter()));\n  } else {\n    return null;\n  }\n}\n\n\nfunction withEatWhitespace<T>(procedure: (parsable: Parsable) => T) {\n  return function(parsable: Parsable) {\n    eatWhitespace(parsable);\n    return procedure(parsable);\n  };\n}\n\nexport const peekWhitespaceSeparatedCharacter = \n  withEatWhitespace((p) => p.peekCharacter());\nexport const eatWhitespaceSeparatedCharacter =\n  withEatWhitespace((p) => p.eatCharacter());\nexport const requireWhitespaceSeparatedCharacter =\n  (p: Parsable, c: char) => withEatWhitespace((p) => p.requireCharacter(c))(p);\nexport const eatWhitespaceSeparatedToken =\n  withEatWhitespace(eatIdentifier);\nexport const eatWhitespaceSeparatedString =\n  (p: Parsable, options: TryParseStringOptions) => withEatWhitespace((p) => tryParseString(p, options))(p);\n\nexport function eatWhitespace(parsable: Parsable) {\n  while (parsable.stillParsing()) {\n    const peeked = parsable.peekCharacter();\n    if (peeked === \" \" || peeked === \"\\t\" || peeked === \"\\n\" || peeked === \"\\r\") {\n      parsable.eatCharacter();\n    } else {\n      break;\n    }\n  }\n}\n","/*\n  This is the markdown preprocessor for any special extensions we might want to support.\n  \n  Does not really do tokenizing, so be ware of dragons.\n */\nimport styles from \"components/Article/Article.module.scss\";\nimport {\n  Parsable,\n  intoParsable,\n  tryParseString,\n  eatIdentifier,\n  eatWhitespace,\n  peekWhitespaceSeparatedCharacter,\n  eatWhitespaceSeparatedCharacter,\n  eatWhitespaceSeparatedToken,\n  requireWhitespaceSeparatedCharacter,\n  eatWhitespaceSeparatedString,\n} from \"utils/intoParsable\";\n\nexport interface HeaderInformation {\n  level: number,\n  text: string\n}\nexport interface MarkdownParsedMetaInformation {\n  processed: string,\n  imageLinks: string[],\n  headers: HeaderInformation[],\n}\n\nfunction pipeSeparatorErrorCheck(parsable: Parsable) {\n  if (!requireWhitespaceSeparatedCharacter(parsable, \"|\")) {\n    if (eatWhitespaceSeparatedToken(parsable) || tryParseString(parsable, { delimiter: \"'\" })) {\n      console.error(\"Missing pipe separator!\");\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function preprocessMarkdown(stringInput: string): MarkdownParsedMetaInformation {\n  let result = \"\";\n  const input = intoParsable(stringInput);\n\n  const actualResult: MarkdownParsedMetaInformation = {\n    processed: \"\",\n    imageLinks: [],\n    headers: []\n  };\n\n  while (input.stillParsing()) {\n    if (input.requireCharacter(\"\\\\\")) {\n      const nextCharacter = input.eatCharacter();\n      if (nextCharacter === \"\\n\") {\n        result += \"<p><br/></p>\\n\";\n      } else {\n        result += nextCharacter;\n      }\n    } else if (input.requireCharacter(\"@\")) {\n      if (input.requireCharacter(\"@\")) {\n        let has_end = false;\n        /*\n          Whenever our region fails to parse it'll just refuse to output anything.\n          \n          @ asdf @ asdf -> @ asdf @ asdf\n          @@ asdf @ asdf -> null\n          @@ asdf @@ asdf -> whatever we would've parsed.\n          \n          if you need multiple @ signs consecutively just do\n          \\@\\@ or @\\@.\n         */\n        const inbetween = intoParsable(\n          input.consumeUntil(\n            function () {\n              if (input.requireCharacter(\"@\")) {\n                /*\n                  When we encounter an @ sign, it's likely to be the end of parsing a \"region\".\n                 */\n                if (input.requireCharacter(\"@\")) {\n                  has_end = true;\n                }\n                return true;\n              }\n              return false;\n            }\n          )\n        );\n\n        if (inbetween && has_end) {\n          let image_tag = \"<img \";\n          let error = false;\n\n          // float style for the classList.\n          let floatingMethod = \"\";\n          let captionString = \"\";\n\n          // TEST?\n          const width = 150;\n\n          while (inbetween.stillParsing() && !error) {\n            const property = eatWhitespaceSeparatedToken(inbetween);\n\n            if (property === \"floatingMethod\") {\n              if (requireWhitespaceSeparatedCharacter(inbetween, \"=\")) {\n                floatingMethod = eatWhitespaceSeparatedToken(inbetween) || \"\";\n                error = error || pipeSeparatorErrorCheck(inbetween);\n              }\n            } else if (property === \"caption\") {\n              if (requireWhitespaceSeparatedCharacter(inbetween, \"=\")) {\n                const maybe_string = eatWhitespaceSeparatedString(inbetween, { delimiter: \"'\", acceptMultiline: true });\n\n                if (maybe_string) {\n                  captionString = maybe_string;\n                } else {\n                  console.error(\"No string for caption string?\");\n                  error = true;\n                }\n              }\n\n              error = error || pipeSeparatorErrorCheck(inbetween);\n            } else if (property) {\n              image_tag += property;\n              if (requireWhitespaceSeparatedCharacter(inbetween, \"=\")) {\n                image_tag += \"=\";\n                if (peekWhitespaceSeparatedCharacter(inbetween) === \"'\") {\n                  const maybe_string = tryParseString(inbetween, { delimiter: \"'\" });\n\n                  if (maybe_string) {\n                    image_tag += \"'\" + maybe_string + \"'\";\n                    if (property === \"src\") {\n                      actualResult.imageLinks.push(maybe_string);\n                    }\n                  } else {\n                    console.error(\"No string value?\");\n                    error = true;\n                  }\n                } else {\n                  const value_identifier = eatWhitespaceSeparatedToken(inbetween);\n                  if (value_identifier) {\n                    image_tag += value_identifier;\n                  } else {\n                    console.error(\"No value identifier?\");\n                    error = true;\n                  }\n                }\n\n                error = error || pipeSeparatorErrorCheck(inbetween);\n              } else {\n                console.error(\"Missing assignment for property?\");\n                error = true;\n              }\n            } else {\n              console.error(\"Could not find property name!\");\n              error = true;\n            }\n            image_tag += \" \";\n          }\n\n          if (captionString !== \"\") {\n            image_tag += `class=\"${styles.captionImagePreview}\"`;\n          }\n\n          if (!error) {\n            if (captionString !== \"\") {\n              image_tag += \"/>\";\n\n              let floatingMethodStr = \"\";\n              switch (floatingMethod) {\n              case \"floatLeft\": floatingMethodStr = styles.floatLeft; break;\n              case \"floatCenter\": floatingMethodStr = styles.floatCenter; break;\n              case \"floatRight\": floatingMethodStr = styles.floatRight; break;\n              }\n\n              result += `<div class=\"${styles.captionBox + \" \" + floatingMethodStr}\" style=\"width: ${width+2}px;\">\n                          ${image_tag}\n                          <div class=${styles.captionBoxInner}>\n                            <p contenteditable=\"false\">${captionString}</p>\n                          </div>\n                          </div>`;\n            } else {\n              image_tag += \"class='\";\n              switch (floatingMethod) {\n              case \"floatLeft\": image_tag += styles.floatLeft; break;\n              case \"floatCenter\": image_tag += styles.floatCenter; break;\n              case \"floatRight\": image_tag += styles.floatRight; break;\n              }\n              image_tag += \"'\";\n              image_tag += \"/>\";\n              result += image_tag;\n            }\n          } else {\n            console.log(\"error happened\");\n          }\n        } else {\n          // not valid tag. Don't do anything.\n          // maybe add a newline since there should really only be one image per\n          // line as per markup style.\n          result += \"\\n\";\n        }\n      } else {\n        result += \"@\";\n      }\n    } else {\n      const peeked = input.peekCharacter();\n      if (peeked === \"#\") {\n        const headerCount = input.consumeUntil(() => input.peekCharacter() !== \"#\").length;\n        const textContents = input.consumeUntil(() => input.peekCharacter() === \"\\n\");\n\n        actualResult.headers.push({\n          level: headerCount,\n          text: textContents\n        });\n\n        const generatedHeader = `\\n<h${headerCount} id=\"${textContents}\">${textContents}</h${headerCount}>`;\n        result += generatedHeader;\n      }\n\n      result += input.eatCharacter();\n    }\n  }\n\n  actualResult.processed = result;\n  return actualResult as MarkdownParsedMetaInformation;\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"dropOut\":\"NoticeBanner_dropOut__xHI9w\",\"dropIn\":\"NoticeBanner_dropIn__13Lbx\",\"drop-in\":\"NoticeBanner_drop-in__35L8R\",\"main\":\"NoticeBanner_main__U4IxO\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"main\":\"bottomToolbar_main__1Ifz4\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"active\":\"RichTextEditor_active__1h0a5\",\"button\":\"RichTextEditor_button__1xq7i\",\"widgetbar\":\"RichTextEditor_widgetbar__1PBAD\",\"tageditor\":\"RichTextEditor_tageditor__9hfWg\",\"tageditor_tag\":\"RichTextEditor_tageditor_tag__1YL1o\",\"settingsWindow\":\"RichTextEditor_settingsWindow__1eRWA\",\"unfocused\":\"RichTextEditor_unfocused__1X8Mv\",\"imageContextSettingsWindow\":\"RichTextEditor_imageContextSettingsWindow__3-quQ\",\"hyperlinkContextSettingsWindow\":\"RichTextEditor_hyperlinkContextSettingsWindow__2Mppc\",\"xOut\":\"RichTextEditor_xOut__nCYFH\",\"alignToBottom\":\"RichTextEditor_alignToBottom__AT47V\",\"blotOut\":\"RichTextEditor_blotOut__2GqyV\",\"imagePreview\":\"RichTextEditor_imagePreview__JsRjT\",\"contextGroupedRadio\":\"RichTextEditor_contextGroupedRadio__7Mqsy\",\"currentlySelected\":\"RichTextEditor_currentlySelected__3rAoL\",\"dimensionPicker\":\"RichTextEditor_dimensionPicker__306vO\",\"contextMenu\":\"RichTextEditor_contextMenu__8Bp23\",\"open-up\":\"RichTextEditor_open-up__4iRhN\"};","import noticeBannerStyles from \"./NoticeBanner.module.scss\";\nimport { useState } from \"react\";\n\nexport function NoticeBanner({\n  children, dirtyFlag\n}: {\n  children: React.ReactNode;\n  dirtyFlag: boolean;\n}) {\n  const styles = [noticeBannerStyles.dropOut, noticeBannerStyles.dropIn];\n\n  const [selfDirtyFlag, updateSelfDirtyFlag] = useState(dirtyFlag);\n  const [style, updateStyle] = useState(0);\n\n  if (dirtyFlag !== selfDirtyFlag) {\n    updateStyle((style + 1));\n    updateSelfDirtyFlag(!selfDirtyFlag);\n  }\n\n  return (\n    <div className={noticeBannerStyles.main + \" \" + styles[style % 2]}>\n      {children}\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport { dictionaryUpdateKey, dictionaryUpdateKeyNested } from \"utils/functions\";\n\nexport type WidgetCategoryDic = Record<string,WidgetCategory>;\nexport type WidgetInformationDic = Record<string, WidgetInformation>;\n\nexport interface WidgetInformation {\n  name: string,\n  display?: JSX.Element,\n  command: string,\n  argument?: string,\n  category?: string,\n}\n\nexport interface WidgetCategory {\n  active: string | null,\n  types: WidgetInformationDic\n}\n\nexport const widgets: WidgetCategoryDic = {\n  heading: {\n    active: null,\n    types: {\n      h1: { name: \"Heading 1\", display: <b>h1</b>, command: \"heading\", argument: \"H1\", category: \"heading\" },\n      h2: { name: \"Heading 2\", display: <b>h2</b>, command: \"heading\", argument: \"H2\", category: \"heading\" },\n      h3: { name: \"Heading 3\", display: <b>h3</b>, command: \"heading\", argument: \"H3\", category: \"heading\" },\n      h4: { name: \"Heading 4\", display: <b>h4</b>, command: \"heading\", argument: \"H4\", category: \"heading\" },\n      h5: { name: \"Heading 5\", display: <b>h5</b>, command: \"heading\", argument: \"H5\", category: \"heading\" },\n      h6: { name: \"Heading 6\", display: <b>h6</b>, command: \"heading\", argument: \"H6\", category: \"heading\" },\n    }\n  },\n  image: {\n    active: null,\n    types: {\n      image: { name: \"Image\", display: <b>Insert Image</b>, command: \"@_insertImage\", category: \"image\" },\n    }\n  },\n  list: {\n    active: null,\n    types: {\n      orderedList: { name: \"Ordered List\", command: \"insertorderedlist\", category: \"list\" },\n      unorderedList: { name: \"Unordered List\", command: \"insertunorderedlist\", category: \"list\" },\n    }\n  },\n  // disadvantage at the moment. You don't have to do this, but this makes the current format work without code changes\n  bold: {\n    active: null,\n    types: {\n      bold: { name: \"Bold\", display: <b>B</b>, command: \"bold\", category: \"bold\" }\n    }\n  },\n  italic: {\n    active: null,\n    types: {\n      italic: { name: \"Italic\", display: <em>I</em>, command: \"italic\", category: \"italic\" }\n    }\n  },\n  underline: {\n    active: null,\n    types: {\n      underline: { name: \"Underline\", display: <u>UL</u>, command: \"underline\", category: \"underline\" }\n    }\n  },\n  hyperlink: {\n    active: null,\n    types: {\n      hyperlink: { name: \"Hyperlink\", display: <b>HREF</b>, command: \"@_hyperlink\" }\n    }\n  },\n};\n\nexport function toggleWidgetActiveState(widgets: WidgetCategoryDic, widgetId: string, categoryValue?: string) {\n  return dictionaryUpdateKeyNested(\n    widgets,\n    [(categoryValue) ? (categoryValue) : (widgetId), \"active\"],\n    (currentlyActive) => (currentlyActive === widgetId) ? null : widgetId\n  );\n}\n\nexport function flattenWidgetStateTypes(widgets: WidgetCategoryDic): WidgetInformationDic {\n  return Object.entries(widgets).reduce(\n    function (accumulator, [id, { types }]) {\n      return Object.entries(types).reduce(\n        function (accumulator, [key, value]) {\n          const copy = { ...accumulator as WidgetInformationDic };\n          copy[key] = value;\n          return copy;\n        },\n        accumulator\n      );\n    }\n    , {});\n}\n","/*\n  A very minimal in-house Rich Text Editor.\n\n  Please keep this as one giant file. I'd rather sift through\n  a thousand lines here, than going through multiple different files.\n\n  Also this is not a \"modular\" Rich Text Editor, and it isn't really supposed to be.\n  Although it probably could with some slightly more careful thought since most of the logic\n  will work fine.\n  \n  You just need a title element and body element to focus on, and the rest may work just\n  fine.\n\n  NOTE(jerry):\n  Hmmm, I am curious to know what would the best method be to allow for draggable images with\n  captions? It probably doesn't matter too much, but I'd like to know.\n\n  It might not be worth the effort to try and do, as I'm certain someone can probably just\n  put the image at the right place later on.\n\n  I'll probably leave it out until it's requested?\n\n  Why is contenteditable so hacky?\n\n  TODO(jerry):\n  Hmmm, for some reason the float changing of images with captions doesn't work.\n  Investigate later.\n*/\nimport React, {\n  useState,\n  useRef,\n  KeyboardEventHandler,\n  useEffect,\n  CSSProperties,\n} from \"react\";\n\nimport { preprocessMarkdown } from \"utils/preprocessMarkdown\";\nimport {\n  uploadImage,\n  retrieveImageData,\n  classListReplace,\n  classListClear,\n  selectionStackPop,\n  selectionStackPush,\n  dictionaryUpdateKeyNested,\n  isVoidElement,\n} from \"utils/functions\";\n\nimport { renderMarkdown } from \"components/Article/MarkdownRender\";\nimport { renderDomAsMarkdown } from \"utils/DOMIntoMarkdown\";\n\nimport {\n  widgets,\n  toggleWidgetActiveState,\n  flattenWidgetStateTypes,\n} from \"./RichTextEditWidgetInformation\";\n\nimport { Article } from \"app/articlesSlice\";\nimport Input from \"components/Form/Input\";\n\nimport bottomToolbarStyle from \"./bottomToolbar.module.scss\";\nimport editorStyle from \"./RichTextEditor.module.scss\";\nimport articleStyles from \"components/Article/Article.module.scss\";\nimport Button from \"components/UI/Button\";\nimport { AssertionError } from \"assert\";\n\n/** Unsafe wrappers... Cause most of this has to be unsafe to be even possible... **/\n/** Well... Draft.JS is a thing, but that can't exactly do the same thing as this... Otherwise it would require way less code. **/\n/** Although Draft.JS itself is actually pretty big. **/\nfunction unsafeDOMStyleSet(element: HTMLElement, style: string) {\n  // @ts-expect-error\n  element.style = style;\n}\nfunction unsafeReferenceSet<T>(ref: React.RefObject<T>, value: T) {\n  //@ts-expect-error\n  ref.current = value;\n}\n\nfunction ExecuteRichTextCommand(commandName: string, optionalArgument?: string, hookFn?: (name: string) => void) {\n  switch (commandName) {\n  case \"@_insertImage\": {\n    const fileDialog = document.createElement(\"input\");\n    fileDialog.type = \"file\";\n    fileDialog.click();\n    fileDialog.addEventListener(\"change\", fileHandlerOnChange);\n  }\n    break;\n  case \"@_hyperlink\": break;\n  default:\n    document.execCommand(commandName, false, optionalArgument);\n    return;\n  }\n\n  hookFn?.(commandName);\n}\n\nfunction queryRichTextCommand(command: string, wantedValue?: boolean) {\n  /*\n    NOTE(jerry):\n\n    Is there no way to query the selection state of a link?\n\n    I would like to know if this is the case cause otherwise... That's kind of fucked.\n  */\n  if (wantedValue) {\n    return document.queryCommandValue(command);\n  } else {\n    return document.queryCommandState(command);\n  }\n}\n\nfunction fileHandlerOnChange({ target }: Event): void {\n  const probablyFile = (target as HTMLInputElement).files?.[0];\n\n  if (probablyFile)\n    retrieveImageData(probablyFile,\n      function (imgData) {\n        uploadImage(imgData).then(\n          function (imgURL) {\n            if (imgURL.success) {\n              document.execCommand(\"insertImage\", false, imgURL.data.url);\n              document.execCommand(\"insertParagraph\");\n            } else {\n              console.error(\"IMGBB is down. Tony pls get us a server\");\n            }\n          }\n        );\n      });\n}\n\ninterface EditorHandleKeyBindingsProperties {\n  saveDocument: () => void,\n  toggleWidget: (widgetId: string, categoryValue?: string) => void,\n  executeRichTextCommand: typeof ExecuteRichTextCommand,\n  updateDirtyFlag: React.Dispatch<boolean>,\n}\nfunction editorHandleKeybindings({\n  saveDocument,\n  toggleWidget,\n  executeRichTextCommand,\n  updateDirtyFlag\n}: EditorHandleKeyBindingsProperties): KeyboardEventHandler<HTMLDivElement> {\n  return function (event) {\n    const { key, shiftKey, ctrlKey } = event;\n    let disableDefaultBehavior = false;\n    if (ctrlKey) {\n      if (!shiftKey) {\n        switch (key) {\n        case \"s\":\n          saveDocument();\n          disableDefaultBehavior = true;\n          break;\n        case \"b\":\n          toggleWidget(\"bold\");\n          executeRichTextCommand(\"bold\");\n          disableDefaultBehavior = true;\n          break;\n        case \"i\":\n          toggleWidget(\"italic\");\n          executeRichTextCommand(\"italic\");\n          disableDefaultBehavior = true;\n          break;\n        case \"u\":\n          toggleWidget(\"underline\");\n          executeRichTextCommand(\"underline\");\n          disableDefaultBehavior = true;\n          break;\n        case \"1\": case \"2\": case \"3\": case \"4\": case \"5\": case \"6\":\n          toggleWidget(`h${key}`, \"heading\");\n          executeRichTextCommand(\"heading\", `H${key}`);\n          disableDefaultBehavior = true;\n          break;\n        }\n      } else {\n        console.log(\"CTRL and SHIFT\", key);\n        switch (key) {\n        case \"U\":\n          console.log(\"unordered list\");\n          executeRichTextCommand(\"insertunorderedlist\");\n          disableDefaultBehavior = true;\n          break;\n        case \"O\":\n          executeRichTextCommand(\"insertorderedlist\");\n          disableDefaultBehavior = true;\n          break;\n        }\n      }\n    }\n\n    if (disableDefaultBehavior) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else {\n      updateDirtyFlag(true);\n    }\n  };\n}\n\ninterface EditorToolbarProperties {\n  toggleDraftStatus: () => void,\n  saveDocument: () => void,\n  isInitial: boolean,\n}\n\n// TODO better name.\nfunction EditorToolbar({ toggleDraftStatus, saveDocument, isInitial }: EditorToolbarProperties) {\n  return (<div className={bottomToolbarStyle.main}>\n    <Button onClick={() => { toggleDraftStatus(); }}>\n      Toggle Draft Status\n    </Button>\n    <Button onClick={saveDocument}>\n      {(isInitial) ? \"Save Article\" : \"Publish Article\"}\n    </Button>\n  </div>);\n}\n\nfunction TagDisplay({ id, name, removeTag }: { id: string, name: string, removeTag: (id: string) => void }) {\n  return (\n    <div className={editorStyle.tageditor_tag}>\n      <span>\n        <button onClick={(_) => removeTag(id)}>&times;</button>\n      </span>\n      {name}</div>\n  );\n}\n\ninterface ArticleTagEditorProperties {\n  tags: string[];\n  setTagState: React.Dispatch<string[]>;\n}\n\n// You know, this looks ugly, but it's almost hilarious that this is the shortest thing here...\nfunction ArticleTagEditor({ tags, setTagState }: ArticleTagEditorProperties) {\n  const [input, setInput] = useState(\"\");\n\n  function removeTagById(id: string) {\n    setTagState(tags.filter((tagName) => id !== tagName));\n  }\n\n  return (\n    <div\n      className={editorStyle.tageditor}>\n      <button\n        className={editorStyle.button}\n        onClick={() => setTagState([])}\n      >Clear</button>\n      {tags?.map((tag) => <TagDisplay removeTag={removeTagById} key={tag} id={tag} name={tag} />)}\n      <input\n        value={input}\n        onChange={\n          function (event) {\n            setInput(event.target.value);\n          }\n        }\n        onKeyDown={\n          function ({ key }) {\n            if (key === \"Backspace\" && input.length === 0) {\n              setTagState(tags?.slice(0, tags.length - 1));\n            } else if (key === \"Enter\" && input.length > 0) {\n              // too lazy to google for proper function.\n              const doesIndexAlreadyExist = tags?.indexOf(input) !== -1;\n              if (!doesIndexAlreadyExist) {\n                setTagState(tags?.concat([input]));\n                setInput(\"\");\n              }\n            }\n          }\n        }\n      ></input>\n    </div>\n  );\n}\n\ninterface ImageContextSettingsProperties {\n  closeShownStatus: () => void,\n  imageRef: React.RefObject<HTMLImageElement>,\n}\n\nenum ImageDimensionsType {\n  Custom,\n  Default,\n}\n\nenum LayoutFloatMode {\n  Left,\n  Center,\n  Right,\n}\n\n// May return more information in the future?\nexport function imageDOMGetCaption(rootNode: Element | null) {\n  if (rootNode) {\n    let captionTextContents = \"\";\n\n    if (rootNode.tagName === \"IMG\") {\n      const parentNode = (rootNode.parentNode as Element);\n\n      if (parentNode.tagName === \"DIV\") {\n        if (parentNode.classList.contains(articleStyles.captionBox)) {\n          const captionElement = parentNode.getElementsByClassName(articleStyles.captionBoxInner)[0];\n          captionTextContents = captionElement.textContent || \"\";\n        } else {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    return {\n      text: captionTextContents\n    };\n  }\n\n  return undefined;\n}\n\nfunction captionImageThumbnailStyleString(width: number, height: number) {\n  return `width: ${width}px; height: ${height}px;`;\n}\n\nfunction captionImageBlockStyleString(width: number) {\n  return `width: ${width+3}px;`;\n}\n\nfunction floatModeStyle(layoutFloatMode: LayoutFloatMode) {\n  switch (layoutFloatMode) {\n  case LayoutFloatMode.Left:\n    return(articleStyles.floatLeft);\n  case LayoutFloatMode.Center:\n    return(articleStyles.floatCenter);\n  case LayoutFloatMode.Right:\n    return(articleStyles.floatRight);\n  }\n}\n\nfunction imageDOMGetFloatStyle(rootNode: Element | null) : LayoutFloatMode {\n  function styleFromClassList(rootNode: Element) {\n    if (rootNode.classList.contains(articleStyles.floatLeft)) {\n      return LayoutFloatMode.Left;\n    } else if (rootNode.classList.contains(articleStyles.floatCenter)) {\n      return LayoutFloatMode.Center;\n    } else if (rootNode.classList.contains(articleStyles.floatRight)) {\n      return LayoutFloatMode.Right;\n    }\n    return LayoutFloatMode.Left;\n  }\n\n  if (rootNode) {\n    if (imageDOMHasCaption(rootNode)) {\n      const parentNode = (rootNode.parentNode as HTMLElement);\n      return styleFromClassList(parentNode);\n    } else {\n      return styleFromClassList(rootNode);\n    }\n  }\n\n  return LayoutFloatMode.Left;\n}\n\n// You are calling this only if you know you can do this safely.\n// Hahah no checks eh??? What's that first line then?\nfunction imageDOMUpdateCaptionWithNoChecks(rootNode: Element | null, newWidth: number, newHeight: number, layoutFloatMode: LayoutFloatMode, textContent: string) {\n  if (rootNode) {\n    const parentNode = (rootNode.parentNode as HTMLElement);\n\n    if (parentNode.tagName === \"DIV\") {\n      const imageNode = rootNode as HTMLImageElement;\n      unsafeDOMStyleSet(imageNode, captionImageThumbnailStyleString(newWidth, newHeight));\n      imageNode.classList.toggle(articleStyles.captionImagePreview);\n\n      unsafeDOMStyleSet(parentNode, captionImageBlockStyleString(newWidth));\n\n      if (parentNode.classList.contains(articleStyles.captionBox)) {\n        console.log(parentNode.classList);\n        classListReplace(parentNode, [articleStyles.captionBox, floatModeStyle(layoutFloatMode)]);\n        console.log(parentNode.classList);\n\n        const captionElement = parentNode.getElementsByClassName(articleStyles.captionBoxInner)[0];\n        captionElement.children[0].textContent = textContent;\n      }\n    }\n  }\n}\n\nexport function imageDOMHasCaption(rootNode: Element | null) {\n  if (rootNode) {\n    const check = imageDOMGetCaption(rootNode);\n    return check !== undefined;\n  }\n\n  return false;\n}\n\ninterface CaptionedImageDOMInformation {\n  captionNode: HTMLElement,\n  imageNode: HTMLImageElement\n}\nfunction imageDOMConstructCaptionedImage(imageOriginalNode: HTMLImageElement, layoutFloatMode: LayoutFloatMode, captionText: string): CaptionedImageDOMInformation {\n  const result = document.createElement(\"DIV\");\n\n  let image_tag = \"<img \";\n  image_tag += `class=\"${articleStyles.captionImagePreview}\" src=${imageOriginalNode.src} style=\"${captionImageThumbnailStyleString(imageOriginalNode.width, imageOriginalNode.height)}\"></img>`;\n\n  // TODO(jerry): This needs to be factored out, as it is also used by the markdown preprocessor to generate our captions.\n  result.innerHTML = `<div class=\"${articleStyles.captionBox + \" \" + floatModeStyle(layoutFloatMode)}\" style=\"${captionImageBlockStyleString(imageOriginalNode.width)}\">\n          ${image_tag}\n      <div class=${articleStyles.captionBoxInner}>\n        <p contenteditable=\"false\">${captionText}</p>\n      </div>\n    </div>\n    <p></p>`.trim();\n\n\n  const innerResult = result.firstChild;\n  const firstInnerChild = innerResult?.childNodes[0];\n\n  /*\n    Unless this is an out of memory issue, this should not fail because the DOM\n    string isn't malformed in this instance.\n  */\n  if (!firstInnerChild) {\n    throw new AssertionError;\n  }\n\n  return {\n    captionNode: innerResult as HTMLElement,\n    imageNode: firstInnerChild as HTMLImageElement,\n  };\n}\n\n/*\n  TODO(jerry):\n  Like the other context settings, I would prefer if this had more feedback,\n  and obviously I would prefer this to be shorter.\n*/\nfunction ImageContextSettings(properties: ImageContextSettingsProperties) {\n  const imageObject = properties.imageRef?.current;\n  const captionInformation = imageDOMGetCaption(imageObject);\n\n  const originalWidth = (imageObject?.width || 150);\n  const originalHeight = (imageObject?.height || 150);\n\n  const [imageCaptionText, setImageCaptionText] = useState((captionInformation?.text || \"\").trim());\n\n  const [layoutFloatMode, setLayoutFloatMode] = useState(imageDOMGetFloatStyle(imageObject));\n  const [imageAllowsWrapAround, setImageAllowWrapAroundText] = useState(true);\n  const [imageDimensionType, setImageDimensionType] = useState(ImageDimensionsType.Default);\n  const [imageDimensionCustomWidth, setImageDimensionCustomWidth] = useState(originalWidth);\n  const [imageDimensionCustomHeight, setImageDimensionCustomHeight] = useState(originalHeight);\n\n  function scaleByGivenRatio(ratio: number) {\n    setImageDimensionCustomWidth(Math.floor(originalWidth * ratio));\n    setImageDimensionCustomHeight(Math.floor(originalHeight * ratio));\n  }\n\n\n  function applyChanges() {\n    if (imageObject) {\n      let newWidth = imageObject.width;\n      let newHeight = imageObject.height; \n\n      if (imageDimensionType === ImageDimensionsType.Custom) {\n        newWidth = imageDimensionCustomWidth || imageObject.width;\n        newHeight = imageDimensionCustomHeight || imageObject.height;\n      }\n\n      imageObject.width = newWidth;\n      imageObject.height = newHeight;\n\n      const hasCaption = imageDOMHasCaption(imageObject);\n      if (!hasCaption && imageCaptionText === \"\") {\n        classListClear(imageObject);\n        /*\n        NOTE(jerry):\n        This is kind of iffy and I'm not particularly sure how to get the CSS to do\n        this properly.\n  \n        Probably doesn't matter too much...\n\n        Also new styling for input[type=\"check\"] ended up breaking this. That's not so\n        great.\n        */\n        if (!imageAllowsWrapAround) {\n          imageObject.classList.add(articleStyles.noWrapAroundText);\n        }\n\n        imageObject.classList.add(floatModeStyle(layoutFloatMode));\n      } else {\n        if (hasCaption) {\n          imageDOMUpdateCaptionWithNoChecks(imageObject, newWidth, newHeight, layoutFloatMode, imageCaptionText);\n        } else {\n          // build a new caption object...\n          const captionBuildResult =\n            imageDOMConstructCaptionedImage(imageObject as HTMLImageElement, layoutFloatMode, imageCaptionText);\n\n          imageObject.replaceWith(captionBuildResult.captionNode);\n          unsafeReferenceSet(properties.imageRef, captionBuildResult.imageNode);\n        }\n        setImageCaptionText(\"\");\n      }\n    }\n\n    console.log(\"end of apply changes\");\n    properties.closeShownStatus();\n  }\n\n  // This is being done as dirty as possible because I just need it to work.\n  // although you can autogenerate the UI from the objects.\n  return (\n    <div id={editorStyle.blotOut}>\n      <div className={editorStyle.settingsWindow} id={editorStyle.imageContextSettingsWindow}>\n        <h1>Image Settings <a onClick={(_) => properties.closeShownStatus()} className={editorStyle.xOut}>X</a></h1>\n        <div style={{ margin: \"2.5em\" }}>\n          <p style={{textAlign: \"center\"}}><i>{imageObject?.src}</i></p>\n          <div className={editorStyle.imagePreview} dangerouslySetInnerHTML={{\n            __html:\n              function () {\n                if (imageObject) {\n                  return `<img src=${imageObject.src}></img>`;\n                } else {\n                  return \"<p>no image</p>\";\n                }\n              }()\n          }} />\n          {/* Float Type */}\n          <div className={editorStyle.contextGroupedRadio}>\n            {\n\n              [\n                { text: \"Left\", type: LayoutFloatMode.Left },\n                { text: \"Center\", type: LayoutFloatMode.Center },\n                { text: \"Right\", type: LayoutFloatMode.Right },\n              ].map((({ text, type }) => (\n                <a className={((type === layoutFloatMode) ? editorStyle.currentlySelected : \"\")}\n                  key={type}\n                  onClick={(e) => setLayoutFloatMode(type)}>\n                  {text}\n                </a>)))\n            }\n          </div>\n          <hr></hr>\n          {/* Dimension Type */}\n          <div className={editorStyle.contextGroupedRadio}>\n            {\n\n              [\n                { text: \"Default\", type: ImageDimensionsType.Default },\n                { text: \"Custom\", type: ImageDimensionsType.Custom },\n              ].map((({ text, type }) => (\n                <a className={((type === imageDimensionType) ? editorStyle.currentlySelected : \"\")}\n                  key={type}\n                  onClick={(e) => setImageDimensionType(type)}>\n                  {text}\n                </a>)))\n            }\n          </div>\n          <div className={(imageDimensionType !== ImageDimensionsType.Custom) ? editorStyle.unfocused : \"\"} id={editorStyle.dimensionPicker}>\n            <h2>Resolution Selection</h2>\n            <input\n              value={imageDimensionCustomWidth}\n              onChange={(e) => scaleByGivenRatio(Number.parseInt(e.target.value) / originalWidth) }\n              type=\"number\"></input>\n            <span>x</span>\n            <input\n              value={imageDimensionCustomHeight}\n              onChange={(e) => scaleByGivenRatio(Number.parseInt(e.target.value) / originalHeight) }\n              type=\"number\"></input>\n          </div>\n          {/*Caption Text*/}\n          <hr></hr>\n          <p style={{textAlign: \"center\"}}>&ldquo;{imageCaptionText}&rdquo;</p>\n          <Input\n            label=\"Image Caption\"\n            changeHandler={\n              function (e) {\n                setImageCaptionText(e.target.value);\n              }\n            }\n            defaultValue={imageCaptionText}\n            value={imageCaptionText} />\n          {/*\n          Wrap\n\n          What is this supposed to do again?\n          */}\n          {\n            /*\n          <label>Wrap Around</label>\n          <input type=\"checkbox\" \n            checked={imageAllowsWrapAround}\n            onChange={\n              function(e) {\n                setImageAllowWrapAroundText(e.target.checked);\n              }\n            }></input>\n            */\n          }\n        </div>\n        <div className={editorStyle.alignToBottom}>\n          <button onClick={applyChanges}>Apply Changes</button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\ninterface HyperlinkContextSettingsProperties {\n  closeShownStatus: () => void,\n  hyperlinkRef: React.RefObject<HTMLAnchorElement>,\n}\n\n/*\n  TODO(jerry):\n\n  I would like this to give more feedback regarding inputs.\n*/\nfunction HyperlinkContextSettings(properties: HyperlinkContextSettingsProperties) {\n  const [hyperlinkText, setHyperlinkText] = useState(\"\");\n  const [hyperlinkAnchorText, setHyperlinkAnchorText] = useState(\"\");\n\n  useEffect(() => { selectionStackPush(); }, []);\n\n  function applyChanges() {\n    console.log(properties.hyperlinkRef.current);\n    if (hyperlinkText !== \"\" && hyperlinkAnchorText !== \"\") {\n      selectionStackPop();\n      if (!properties.hyperlinkRef?.current) {\n        ExecuteRichTextCommand(\"insertHTML\", `<a href=${hyperlinkAnchorText}>${hyperlinkText}</a>`);\n      } else {\n        properties.hyperlinkRef.current.href = hyperlinkAnchorText;\n        properties.hyperlinkRef.current.textContent = hyperlinkText;\n      }\n      properties.closeShownStatus();\n    }\n  }\n\n  return (\n    <div id={editorStyle.blotOut}>\n      <div className={editorStyle.settingsWindow} id={editorStyle.hyperlinkContextSettingsWindow}>\n        <h1>Hyperlink Creation <a onClick={(_) => properties.closeShownStatus()} className={editorStyle.xOut}>X</a></h1>\n        <div style={{ margin: \"2.5em\" }}>\n          <p>Hyperlink</p>\n          <Input \n            label=\"Hyperlink Contents\"\n            changeHandler={\n              function (e) {\n                setHyperlinkText(e.target.value);\n              }\n            }\n            defaultValue={hyperlinkText}\n            value={hyperlinkText} />\n          <p>Anchor Location</p>\n          <Input\n            label=\"Hyperlink Location\"\n            changeHandler={\n              function (e) {\n                setHyperlinkAnchorText(e.target.value);\n              }\n            }\n            defaultValue={hyperlinkAnchorText}\n            value={hyperlinkAnchorText} />\n        </div>\n        <div className={editorStyle.alignToBottom}>\n          <button onClick={applyChanges}>Apply Changes</button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\ninterface Position {\n  x: number,\n  y: number,\n}\n\ninterface ImageContextMenuProperties {\n  image: HTMLImageElement | null,\n  position: Position,\n  openEdit: () => void,\n  close: () => void,\n}\n\nfunction absolutePositionAt(x: number, y: number): CSSProperties {\n  return {\n    position: \"absolute\",\n    left: `${x}px`,\n    top: `${y}px`,\n  };\n}\n\nfunction ImageContextMenu(properties: ImageContextMenuProperties) {\n  const {position, image, openEdit, close} = properties;\n  if (!image) return <></>;\n\n  return (\n    <div className={editorStyle.contextMenu} style={absolutePositionAt(position.x, position.y)}>\n      <i style={{margin: \"2em\"}}>{image.src || \"No image selected?\"}</i>\n      <br></br>\n      <br></br>\n      <button onClick={openEdit}>Edit</button>\n      <button onClick={\n        function() {\n          const hasCaption = imageDOMHasCaption(image);\n          if (hasCaption) {\n            ((image.parentNode) as HTMLElement).remove();\n          } else {\n            image.remove();\n          }\n          close();\n        }}>Remove Image</button>\n    </div>\n  );\n}\n\ninterface HyperlinkContextMenuProperties {\n  link: HTMLAnchorElement | null,\n  position: Position,\n  openEdit: () => void,\n  close: () => void,\n}\n\nfunction HyperlinkContextMenu(properties: HyperlinkContextMenuProperties) {\n  const {position, link, openEdit, close} = properties;\n  if (!link) return <></>;\n\n  return (\n    <div className={editorStyle.contextMenu} style={absolutePositionAt(position.x, position.y)}>\n      <i style={{margin: \"2em\"}}>{link.href || \"No href selected?\"}</i>\n      <br></br>\n      <br></br>\n      <button onClick={openEdit}>Edit</button>\n      <button onClick={\n        function() {\n          link.remove();\n          close();\n        }\n      }>Remove Hyperlink</button>\n    </div>\n  );\n}\n\ninterface RichTextEditorProperties {\n  submissionHandler: (f: { name: string, tags: string[], content: string; }) => void,\n  currentArticle?: Article,\n  updateDirtyFlag: React.Dispatch<React.SetStateAction<boolean>>,\n  toggleDraftStatus: () => void,\n}\n\n/*\n  why does image have a cursor? This is such a stupid stupid hack, but this one is technically unavoidable\n  behavior afaik.\n\n  We could make images not contenteditable and handle their case individually? But I don't think images get\n  focus so I can't really do the thing I want to do.\n\n  NOTE(jerry): name is to get a nice little laugh. I promise I'm more professional than this.\n*/\nfunction put_the_cursor_in_a_fucking_place_i_can_actually_type_in() {\n  const currentSelection = window.getSelection();\n  const anchorNode = currentSelection?.anchorNode;\n\n  if (anchorNode && isVoidElement(anchorNode)) {\n    const anchorNodeAsElement = anchorNode as Element;\n\n    if (anchorNodeAsElement.nextElementSibling) {\n      currentSelection?.collapse(anchorNodeAsElement.nextElementSibling);\n    } else {\n      if (anchorNodeAsElement.parentNode) {\n        let goodTarget = anchorNodeAsElement.parentNode.nextSibling;\n        // when the hell does the browser decide to generate <BR> and not <P><BR></P>?????\n        while (goodTarget && isVoidElement(goodTarget)) {\n          goodTarget = goodTarget.nextSibling;\n        }\n\n        currentSelection?.collapse(goodTarget);\n        currentSelection?.collapseToEnd();\n      }\n    }\n  }\n}\n\nexport function RichTextEditor({\n  submissionHandler,\n  currentArticle,\n  updateDirtyFlag,\n  toggleDraftStatus\n}: RichTextEditorProperties) {\n  const [initialArticleState, _] = useState(currentArticle);\n  const [tagEditorShown, setTagEditorVisibility] = useState(true);\n\n  const [imageContextEditorShown, setImageContextEditorVisibility] = useState(false);\n  const [hyperlinkContextEditorShown, setHyperlinkContextEditorShown] = useState(false);\n\n  const [tags, setTagState] = useState((currentArticle?.tags) || []);\n\n  const editableTitleDOMRef = useRef<HTMLHeadingElement>(null);\n  const editableAreaDOMRef = useRef<HTMLDivElement>(null);\n  const currentImageRef = useRef<HTMLImageElement>(null);\n  const currentHyperlinkRef = useRef<HTMLAnchorElement>(null);\n\n  const [imageContextMenuPosition, setImageContextMenuPosition] = useState<undefined | Position>(undefined);\n  const [hyperLinkContextMenuPosition, setHyperLinkContextMenuPosition] = useState<undefined | Position>(undefined);\n\n  useEffect(\n    function () {\n      document.execCommand(\"defaultParagraphSeparator\", false, \"p\");\n      if (editableAreaDOMRef.current) {\n        editableAreaDOMRef.current.onmousedown =\n          function (e) {\n            /*/goodT\n              I do not know of a way to get a ref into newly generated\n              HTML, so we can't exactly do this in a very React way.\n \n              The only other thing I could think of is generating react friendly\n              mark-up, but I don't want a ref to every single element, but I could\n              probably do it with\n \n              onClick for all of the images to set a \"currentFocusedImage\" to whatever\n              was clicked on, which would suffice.\n \n              I'm pretty sure markdown-it exposes an \"AST\" sort of thing so I can get\n              that to generate JSX which can use the above. That's later though.\n            */\n\n            const target = e.target as HTMLElement;\n\n            setImageContextMenuPosition(undefined);\n            unsafeReferenceSet(currentImageRef, null);\n            unsafeReferenceSet(currentHyperlinkRef, null);\n\n            if (target?.tagName === \"IMG\") {\n              unsafeReferenceSet(currentImageRef, target);\n              setImageContextMenuPosition({\n                x: target.offsetLeft,\n                y: target.offsetTop,\n              });\n            } else if (target?.tagName === \"A\") {\n              unsafeReferenceSet(currentHyperlinkRef, target);\n              setHyperLinkContextMenuPosition({\n                x: target.offsetLeft,\n                y: target.offsetTop,\n              });\n            }\n          };\n      }\n    }, [editableAreaDOMRef]);\n\n  const [widgetStates, updateWidgetState] = useState(widgets);\n\n  function saveDocument() {\n    if (editableAreaDOMRef.current && editableTitleDOMRef.current) {\n      const markdownText = renderDomAsMarkdown(editableAreaDOMRef.current);\n      console.log(\"output:\");\n      console.log(markdownText);\n      submissionHandler({\n        name: (initialArticleState?.name) || (editableTitleDOMRef.current.textContent || \"\"),\n        content: markdownText,\n        tags: tags\n      });\n\n      if (initialArticleState === undefined) {\n        editableAreaDOMRef.current.innerHTML = renderMarkdown(preprocessMarkdown(markdownText).processed);\n      }\n    }\n  }\n\n  // would only apply to a few relevant states.\n  function _toggleWidgetActiveState(widgetId: string, categoryValue?: string) {\n    updateWidgetState(toggleWidgetActiveState(widgetStates, widgetId, categoryValue));\n  }\n\n  function synchronizeCommandStateToWidgetBar() {\n    put_the_cursor_in_a_fucking_place_i_can_actually_type_in();\n    updateWidgetState(\n      Object.keys(widgetStates).reduce(\n        (newWidgetState, type) => {\n          return dictionaryUpdateKeyNested(newWidgetState, [type, \"active\"],\n            (type === \"heading\") ?\n              () => queryRichTextCommand(type, true) :\n              () => queryRichTextCommand(type) ? type : null\n          );\n        }, widgetStates)\n    );\n  }\n\n  return (\n    <>\n      <h1\n        className={articleStyles.title}\n        contentEditable={(initialArticleState) ? \"false\" : \"true\"}\n        ref={editableTitleDOMRef}\n      >\n        {(currentArticle) ? currentArticle.name : \"Edit New Title\"}\n      </h1>\n      <div>\n        <div\n          contentEditable={true}\n          className={articleStyles.article}\n          style={{ minHeight: \"50%\" }}\n          onSelect={synchronizeCommandStateToWidgetBar}\n          onKeyDown={editorHandleKeybindings({\n            saveDocument: saveDocument,\n            toggleWidget: _toggleWidgetActiveState,\n            executeRichTextCommand: ExecuteRichTextCommand,\n            updateDirtyFlag: updateDirtyFlag,\n          })}\n          dangerouslySetInnerHTML={\n            { __html: renderMarkdown(preprocessMarkdown((initialArticleState) ? initialArticleState.content : \"Begin typing your article.\").processed) }\n          }\n          ref={editableAreaDOMRef}>\n        </div>\n      </div>\n      <br></br>\n      <br></br>\n      <div className={editorStyle.widgetbar}> {/*requires styling*/}\n        <button style={{ float: \"left\", marginLeft: \"3em\" }}\n          className={editorStyle.button}\n          onClick={() => setTagEditorVisibility(!tagEditorShown)}>\n          Toggle Tag Editor</button>\n        {\n          Object.entries(flattenWidgetStateTypes(widgetStates)).map(\n            ([widgetId, widget]) =>\n              <button\n                key={widgetId}\n                id={widgetId}\n                className={\n                  // NOTE(jerry): Wtf happened here?\n                  (widget.category) ? (((widgetStates[\n                    (widget.category !== undefined) ?\n                      widget.category :\n                      widgetId].active) === widgetId) ?\n                    editorStyle.active : editorStyle.button)\n                    : editorStyle.button\n                }\n                onClick={\n                  (_) => {\n                    _toggleWidgetActiveState(widgetId, widget.category);\n                    ExecuteRichTextCommand(widget.command, \n                      widget.argument,\n                      function (name: string) {\n                        if (name === \"@_hyperlink\") {\n                          setHyperlinkContextEditorShown(true);\n                        }\n                      });\n                  }\n                }>{(widget.display) ? widget.display : widget.name}\n              </button>\n          )\n        }\n        <button style={{ float: \"right\", marginRight: \"3em\" }}\n          className={editorStyle.button}\n        >Set as Featured Article</button>\n        {(tagEditorShown) ? <ArticleTagEditor setTagState={setTagState} tags={tags} /> : <></>}\n      </div>\n      <EditorToolbar isInitial={(!!initialArticleState)} saveDocument={saveDocument} toggleDraftStatus={toggleDraftStatus} />\n      { (imageContextEditorShown) ?\n        <ImageContextSettings imageRef={currentImageRef} closeShownStatus={() => { setImageContextEditorVisibility(false); }} /> : <></>}\n      {(hyperlinkContextEditorShown) ?\n        <HyperlinkContextSettings \n          hyperlinkRef={currentHyperlinkRef}\n          closeShownStatus={() => { setHyperlinkContextEditorShown(false); }} /> : <></>}\n      { (imageContextMenuPosition) ? (\n        <ImageContextMenu \n          close={ () => setImageContextMenuPosition(undefined) }\n          openEdit={\n            function() {\n              setImageContextMenuPosition(undefined);\n              setImageContextEditorVisibility(true);\n            }\n          } image={currentImageRef.current} position={imageContextMenuPosition}/>\n      ) : <></> }\n      {(hyperLinkContextMenuPosition) ? (\n        <HyperlinkContextMenu\n          close={() => setHyperLinkContextMenuPosition(undefined)}\n          openEdit={\n            function () {\n              setHyperLinkContextMenuPosition(undefined);\n              setHyperlinkContextEditorShown(true);\n            }\n          } link={currentHyperlinkRef.current} position={hyperLinkContextMenuPosition} />\n      ) : <></>}\n    </>\n  );\n}\n","import { useState } from \"react\";\n\nimport { useAppDispatch } from \"app/hooks\";\nimport { insertArticle, Article } from \"app/articlesSlice\";\n\nimport { NoticeBanner } from \"./Editors/NoticeBanner\";\nimport { RichTextEditor } from \"./Editors/RichTextEditor\";\n// import { TagEditor } from 'pages/Admin/TagEditor';\n\nexport default function Admin({\n  currentArticle\n}: {\n  currentArticle?: Article;\n}) {\n  const dispatch = useAppDispatch();\n  const [dirtyFlag, updateDirtyFlag] = useState(false);\n\n  const [draftStatus, updateDraftStatus] = useState((currentArticle?.draftStatus));\n\n  function submitHandler(input: Article, onFinishedCallback?: (input: Article) => void) {\n    dispatch(insertArticle(input));\n    onFinishedCallback?.(input);\n  }\n\n  const submissionHandler = (\n    submissionData: {\n      name: string;\n      content: string;\n      tags?: string[];\n    }\n  ) => {\n    submitHandler(\n      { ...submissionData, draftStatus: !!draftStatus },\n      ({ name }) => {\n        console.log(`Article ${name} written!`);\n        updateDirtyFlag(false);\n      }\n    );\n  };\n\n  return (\n    <>\n      <h2>{(draftStatus) ? \"DRAFT*\" : \"WILL PUBLISH ON SAVE\"}</h2>\n      <NoticeBanner dirtyFlag={dirtyFlag}>You have unsaved changes!</NoticeBanner>\n      <RichTextEditor\n        submissionHandler={submissionHandler}\n        currentArticle={currentArticle}\n        updateDirtyFlag={updateDirtyFlag}\n        toggleDraftStatus={() => updateDraftStatus(!draftStatus)}\n      />\n\n      {/* <TagEditor currentArticle={currentArticle}/> */}\n    </>\n  );\n}\n"],"sourceRoot":""}